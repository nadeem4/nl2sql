from __future__ import annotations

from typing import Any, Dict, List, Optional, TypedDict, Annotated, Union, Set
import operator

from pydantic import BaseModel, ConfigDict, Field

# Re-export node schemas
from nl2sql.nodes.schema.schemas import TableInfo, SchemaInfo, ForeignKey
from nl2sql.nodes.planner.schemas import (
    PlanModel, TableRef, JoinSpec, FilterSpec, ColumnRef, 
    HavingSpec, OrderSpec
)
from nl2sql.nodes.intent.schemas import IntentModel
from nl2sql.nodes.executor.schemas import ExecutionModel

from nl2sql.nodes.decomposer.schemas import DecomposerResponse
from nl2sql.nodes.aggregator.schemas import AggregatedResponse
from nl2sql.nodes.router.schemas import RoutingInfo


def merge_dicts(left: Dict[str, Any], right: Dict[str, Any]) -> Dict[str, Any]:
    """Reduces dictionaries by merging them."""
    if not left:
        return right
    if not right:
        return left
    return {**left, **right}


def merge_ids_set(left: Optional[Set[str]], right: Optional[Set[str]]) -> Set[str]:
    """Reduces datasource IDs by unioning them into a set."""
    left = left or set()
    if isinstance(left, list):
        left = set(left)
        
    if right is None:
        return left
    
    if isinstance(right, list):
        right = set(right)
        
    return left | right

class GraphState(BaseModel):
    """
    State definition for the NL2SQL LangGraph pipeline.

    Attributes:
        user_query (str): The original natural language query from the user.
        plan (Optional[Dict[str, Any]]): The execution plan generated by the planner.
        sql_draft (Optional[str]): The draft SQL query generated by the generator.
        schema_info (Optional[SchemaInfo]): The retrieved schema information.
        validation (Dict[str, Any]): Validation results and capabilities.
        intent (Optional[IntentModel]): The classified intent of the query.
        execution (Optional[ExecutionModel]): The result of SQL execution.
        errors (List[str]): List of errors encountered during execution.
        retry_count (int): Counter for retry attempts.
        reasoning (List[Dict[str, Any]]): Accumulated reasoning steps from nodes.
        datasource_id (Set[str]): Set of potential datasource IDs.
        selected_datasource_id (Optional[str]): The ID of the specifically selected datasource.
        sub_queries (Optional[List[str]]): List of sub-queries when decomposing complex queries.
        intermediate_results (List[Any]): Results accumulated from parallel branches.
        query_history (List[Dict[str, Any]]): History of executed queries and results.
        final_answer (Optional[str]): The final synthesized answer returned to the user.
        routing_info (Dict[str, RoutingInfo]): Detailed routing metadata and scores.
    """
    model_config = ConfigDict(extra="ignore", arbitrary_types_allowed=True)
    
    user_query: str
    plan: Optional[Dict[str, Any]] = None
    sql_draft: Optional[str] = None
    schema_info: Optional[SchemaInfo] = None
    validation: Dict[str, Any] = Field(default_factory=dict)
    intent: Optional[IntentModel] = None
    execution: Optional[ExecutionModel] = None
    errors: List[str] = Field(default_factory=list)
    retry_count: int = 0
    reasoning: Annotated[List[Dict[str, Any]], operator.add] = Field(default_factory=list)
    datasource_id: Annotated[Set[str], merge_ids_set] = Field(default_factory=set)
    selected_datasource_id: Optional[str] = None
    sub_queries: Optional[List[str]] = None
    intermediate_results: Annotated[List[Any], operator.add] = Field(default_factory=list)
    query_history: Annotated[List[Dict[str, Any]], operator.add] = Field(default_factory=list)
    final_answer: Optional[str] = None
    routing_info: Annotated[Dict[str, RoutingInfo], merge_dicts] = Field(default_factory=dict)
